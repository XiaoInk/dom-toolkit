var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var require_interactor_min = __commonJS({
  "interactor.min.js"(exports, module) {
    (function() {
      const interactor = {
        clickAt(x, y, options = {}) {
          return new Promise((resolve, reject) => {
            const { delay = 0, button = 0, ctrlKey = false, shiftKey = false } = options;
            setTimeout(() => {
              try {
                const element = document.elementFromPoint(x, y);
                if (!element) {
                  reject(new Error(`No element found at coordinates (${x}, ${y})`));
                  return;
                }
                const event = new MouseEvent("click", {
                  clientX: x,
                  clientY: y,
                  button,
                  ctrlKey,
                  shiftKey,
                  bubbles: true,
                  cancelable: true
                });
                element.dispatchEvent(event);
                resolve({
                  element,
                  tagName: element.tagName.toLowerCase(),
                  coordinates: { x, y }
                });
              } catch (error) {
                reject(error);
              }
            }, delay);
          });
        },
        doubleClick(x, y, options = {}) {
          return new Promise(async (resolve, reject) => {
            try {
              await this.clickAt(x, y, { ...options });
              await new Promise((resolve2) => setTimeout(resolve2, 50));
              await this.clickAt(x, y, { ...options });
              const element = document.elementFromPoint(x, y);
              if (element) {
                const dblClickEvent = new MouseEvent("dblclick", {
                  clientX: x,
                  clientY: y,
                  bubbles: true,
                  cancelable: true
                });
                element.dispatchEvent(dblClickEvent);
              }
              resolve({ x, y, eventType: "dblclick" });
            } catch (error) {
              reject(error);
            }
          });
        },
        rightClick(x, y, options = {}) {
          return this.clickAt(x, y, { ...options, button: 2, eventType: "contextmenu" });
        },
        type(x, y, text, options = {}) {
          return new Promise(async (resolve, reject) => {
            try {
              await this.clickAt(x, y, options);
              const element = document.elementFromPoint(x, y);
              if (!element) {
                reject(new Error(`No element found at coordinates (${x}, ${y})`));
                return;
              }
              if (options.clear && element.value !== void 0) {
                element.value = "";
              }
              const typingDelay = options.typingDelay || 100;
              for (let i = 0; i < text.length; i++) {
                const char = text[i];
                const keydownEvent = new KeyboardEvent("keydown", {
                  key: char,
                  char,
                  keyCode: char.charCodeAt(0),
                  bubbles: true,
                  cancelable: true
                });
                const keyupEvent = new KeyboardEvent("keyup", {
                  key: char,
                  char,
                  keyCode: char.charCodeAt(0),
                  bubbles: true,
                  cancelable: true
                });
                const inputEvent = new InputEvent("input", {
                  data: char,
                  bubbles: true,
                  cancelable: true
                });
                element.dispatchEvent(keydownEvent);
                if (element.value !== void 0) {
                  element.value += char;
                  element.dispatchEvent(inputEvent);
                }
                element.dispatchEvent(keyupEvent);
                if (typingDelay > 0) {
                  await new Promise((resolve2) => setTimeout(resolve2, typingDelay));
                }
              }
              resolve({ x, y, text, element });
            } catch (error) {
              reject(error);
            }
          });
        },
        drag(startX, startY, endX, endY, options = {}) {
          return new Promise(async (resolve, reject) => {
            try {
              const { duration = 500 } = options;
              const startElement = document.elementFromPoint(startX, startY);
              if (!startElement) {
                reject(new Error(`No element found at start coordinates (${startX}, ${startY})`));
                return;
              }
              const dragStartEvent = new MouseEvent("mousedown", {
                clientX: startX,
                clientY: startY,
                button: 0,
                bubbles: true,
                cancelable: true
              });
              startElement.dispatchEvent(dragStartEvent);
              const steps = 20;
              const stepDelay = duration / steps;
              for (let i = 1; i <= steps; i++) {
                const progress = i / steps;
                const currentX = startX + (endX - startX) * progress;
                const currentY = startY + (endY - startY) * progress;
                const moveEvent = new MouseEvent("mousemove", {
                  clientX: currentX,
                  clientY: currentY,
                  button: 0,
                  bubbles: true,
                  cancelable: true
                });
                document.dispatchEvent(moveEvent);
                await new Promise((resolve2) => setTimeout(resolve2, stepDelay));
              }
              const dragEndEvent = new MouseEvent("mouseup", {
                clientX: endX,
                clientY: endY,
                button: 0,
                bubbles: true,
                cancelable: true
              });
              document.dispatchEvent(dragEndEvent);
              resolve({ startX, startY, endX, endY });
            } catch (error) {
              reject(error);
            }
          });
        },
        batch(operations, options = {}) {
          return new Promise(async (resolve, reject) => {
            const { delayBetween = 1e3 } = options;
            const results = [];
            try {
              for (let i = 0; i < operations.length; i++) {
                const operation = operations[i];
                let result;
                if (operation.click) {
                  result = await this.clickAt(operation.click.x, operation.click.y, operation.click.options);
                } else if (operation.doubleClick) {
                  result = await this.doubleClick(operation.doubleClick.x, operation.doubleClick.y, operation.doubleClick.options);
                } else if (operation.type) {
                  result = await this.type(operation.type.x, operation.type.y, operation.type.text, operation.type.options);
                } else if (operation.drag) {
                  result = await this.drag(operation.drag.startX, operation.drag.startY, operation.drag.endX, operation.drag.endY, operation.drag.options);
                }
                results.push(result);
                if (delayBetween > 0 && i < operations.length - 1) {
                  await new Promise((resolve2) => setTimeout(resolve2, delayBetween));
                }
              }
              resolve(results);
            } catch (error) {
              reject(error);
            }
          });
        }
      };
      if (typeof module !== "undefined" && module.exports) {
        module.exports = interactor;
      } else {
        window.domToolkitInteractor = interactor;
      }
    })();
  }
});
export default require_interactor_min();
