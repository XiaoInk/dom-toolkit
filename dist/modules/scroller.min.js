var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var require_scroller_min = __commonJS({
  "scroller.min.js"(exports, module) {
    (function() {
      const scroller = {
        getScrollPosition(element = null) {
          if (element) {
            return {
              x: element.scrollLeft,
              y: element.scrollTop,
              scrollWidth: element.scrollWidth,
              scrollHeight: element.scrollHeight,
              clientWidth: element.clientWidth,
              clientHeight: element.clientHeight
            };
          } else {
            return {
              x: window.pageXOffset || document.documentElement.scrollLeft,
              y: window.pageYOffset || document.documentElement.scrollTop,
              scrollWidth: document.documentElement.scrollWidth,
              scrollHeight: document.documentElement.scrollHeight,
              clientWidth: window.innerWidth,
              clientHeight: window.innerHeight
            };
          }
        },
        scroll(directionOrOptions, distance = null, options = {}) {
          return new Promise((resolve, reject) => {
            try {
              if (typeof directionOrOptions === "object") {
                return this.scrollToPosition(directionOrOptions);
              }
              const direction = directionOrOptions;
              const { behavior = "smooth", duration = 500, element = null } = options;
              const currentPos = this.getScrollPosition(element);
              const maxX = element ? element.scrollWidth - element.clientWidth : document.documentElement.scrollWidth - window.innerWidth;
              const maxY = element ? element.scrollHeight - element.clientHeight : document.documentElement.scrollHeight - window.innerHeight;
              let targetX = currentPos.x;
              let targetY = currentPos.y;
              switch (direction.toLowerCase()) {
                case "up":
                  targetY = distance !== null ? Math.max(0, currentPos.y - distance) : 0;
                  break;
                case "down":
                  targetY = distance !== null ? Math.min(maxY, currentPos.y + distance) : maxY;
                  break;
                case "left":
                  targetX = distance !== null ? Math.max(0, currentPos.x - distance) : 0;
                  break;
                case "right":
                  targetX = distance !== null ? Math.min(maxX, currentPos.x + distance) : maxX;
                  break;
                default:
                  throw new Error(`无效的方向: ${direction}. 请使用: up, down, left, right`);
              }
              const scrollOptions = {
                left: targetX,
                top: targetY,
                behavior
              };
              if (element) {
                element.scrollTo(scrollOptions);
              } else {
                window.scrollTo(scrollOptions);
              }
              setTimeout(() => {
                resolve({
                  direction,
                  distance,
                  from: { x: currentPos.x, y: currentPos.y },
                  to: { x: targetX, y: targetY }
                });
              }, duration);
            } catch (error) {
              reject(error);
            }
          });
        },
        scrollToPosition(options = {}) {
          return new Promise((resolve, reject) => {
            try {
              const {
                x = 0,
                y = 0,
                top = false,
                bottom = false,
                left = false,
                right = false,
                up = false,
                down = false,
                distance = null,
                behavior = "smooth",
                element = null,
                duration = 500
              } = options;
              const currentPos = this.getScrollPosition(element);
              let targetX = currentPos.x;
              let targetY = currentPos.y;
              if (up) {
                targetY = distance !== null ? Math.max(0, currentPos.y - distance) : 0;
              } else if (down) {
                const maxY = element ? element.scrollHeight - element.clientHeight : document.documentElement.scrollHeight - window.innerHeight;
                targetY = distance !== null ? Math.min(maxY, currentPos.y + distance) : maxY;
              } else if (left) {
                targetX = distance !== null ? Math.max(0, currentPos.x - distance) : 0;
              } else if (right) {
                const maxX = element ? element.scrollWidth - element.clientWidth : document.documentElement.scrollWidth - window.innerWidth;
                targetX = distance !== null ? Math.min(maxX, currentPos.x + distance) : maxX;
              } else if (x !== 0 || y !== 0) {
                targetX = x;
                targetY = y;
              } else if (top) {
                targetY = 0;
                targetX = 0;
              } else if (bottom) {
                targetY = element ? element.scrollHeight - element.clientHeight : document.documentElement.scrollHeight - window.innerHeight;
              } else if (left) {
                targetX = 0;
              } else if (right) {
                targetX = element ? element.scrollWidth - element.clientWidth : document.documentElement.scrollWidth - window.innerWidth;
              }
              const scrollOptions = {
                left: targetX,
                top: targetY,
                behavior
              };
              if (element) {
                element.scrollTo(scrollOptions);
              } else {
                window.scrollTo(scrollOptions);
              }
              setTimeout(() => {
                resolve({
                  from: { x: currentPos.x, y: currentPos.y },
                  to: { x: targetX, y: targetY },
                  options
                });
              }, duration);
            } catch (error) {
              reject(error);
            }
          });
        },
        scrollBy(x, y, options = {}) {
          return new Promise((resolve, reject) => {
            try {
              const { behavior = "smooth", duration = 500, element = null } = options;
              if (element) {
                element.scrollBy({ left: x, top: y, behavior });
              } else {
                const nativeScrollBy = window.scrollBy;
                window.scrollBy = void 0;
                window.scrollBy({ left: x, top: y, behavior });
                window.scrollBy = nativeScrollBy;
              }
              setTimeout(() => {
                resolve({ x, y });
              }, duration);
            } catch (error) {
              reject(error);
            }
          });
        },
        scrollToElement(element, options = {}) {
          return new Promise((resolve, reject) => {
            try {
              const { behavior = "smooth", block = "start", inline = "nearest", duration = 500 } = options;
              if (typeof element === "string") {
                element = document.querySelector(element);
              }
              if (!element) {
                reject(new Error("未找到目标元素"));
                return;
              }
              element.scrollIntoView({
                behavior,
                block,
                inline
              });
              setTimeout(() => {
                const rect = element.getBoundingClientRect();
                resolve({ element, rect });
              }, duration);
            } catch (error) {
              reject(error);
            }
          });
        },
        scrollAndClick(scrollX, scrollY, clickX, clickY, options = {}) {
          return new Promise(async (resolve, reject) => {
            try {
              const { scrollDuration = 500, clickDelay = 300 } = options;
              await this.scrollToPosition({ x: scrollX, y: scrollY, duration: scrollDuration });
              await new Promise((resolve2) => setTimeout(resolve2, clickDelay));
              if (window.domToolkitInteractor) {
                const clickResult = await window.domToolkitInteractor.clickAt(clickX, clickY, options);
                resolve({
                  scrollPosition: { x: scrollX, y: scrollY },
                  clickPosition: { x: clickX, y: clickY },
                  clickResult
                });
              } else {
                reject(new Error("interactor模块未加载"));
              }
            } catch (error) {
              reject(error);
            }
          });
        },
        batchOperate(operations, options = {}) {
          return new Promise(async (resolve, reject) => {
            try {
              const { scrollDelay = 500, operationDelay = 300 } = options;
              const results = [];
              for (let i = 0; i < operations.length; i++) {
                const operation = operations[i];
                if (operation.scroll) {
                  await this.scroll(operation.scroll.direction, operation.scroll.distance, {
                    duration: scrollDelay,
                    ...operation.scroll.options
                  });
                  await new Promise((resolve2) => setTimeout(resolve2, operationDelay));
                } else if (operation.scrollTo) {
                  await this.scrollToPosition({
                    ...operation.scrollTo,
                    duration: scrollDelay
                  });
                  await new Promise((resolve2) => setTimeout(resolve2, operationDelay));
                }
                if (window.domToolkitInteractor) {
                  if (operation.click) {
                    const result = await window.domToolkitInteractor.clickAt(
                      operation.click.x,
                      operation.click.y,
                      operation.click.options
                    );
                    results.push({ type: "click", result });
                  } else if (operation.type) {
                    const result = await window.domToolkitInteractor.type(
                      operation.type.x,
                      operation.type.y,
                      operation.type.text,
                      operation.type.options
                    );
                    results.push({ type: "type", result });
                  } else if (operation.doubleClick) {
                    const result = await window.domToolkitInteractor.doubleClick(
                      operation.doubleClick.x,
                      operation.doubleClick.y,
                      operation.doubleClick.options
                    );
                    results.push({ type: "doubleClick", result });
                  }
                }
                if (i < operations.length - 1) {
                  await new Promise((resolve2) => setTimeout(resolve2, operationDelay));
                }
              }
              resolve(results);
            } catch (error) {
              reject(error);
            }
          });
        }
      };
      if (typeof module !== "undefined" && module.exports) {
        module.exports = scroller;
      } else {
        window.domToolkitScroller = scroller;
      }
    })();
  }
});
export default require_scroller_min();
